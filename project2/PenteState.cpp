#include "PenteState.h"

#include <iomanip>
#include <random>
#include <set>

PenteState::PenteState() {}

int PenteState::getState(std::array<int, 2> position) const {
  if ((_black & (uint512_t(1U) << (19 * position[0] + position[1]))) != 0)
    return 1;
  if ((_white & (uint512_t(1U) << (19 * position[0] + position[1]))) != 0)
    return -1;
  return 0;
}

int PenteState::getTurn() const { return _turn; }

std::array<int, 2> PenteState::numCaptures() const {
  return { _blackCaptures, _whiteCaptures };
}

int PenteState::winner() const {
  if (_blackCaptures == 5 || patternCount("BBBBB") > 0)
    return 1;
  if (_whiteCaptures == 5 || patternCount("WWWWW") > 0)
    return -1;
  return 0;
}

bool PenteState::gameOver() const {
  if (_blackCaptures == 5 || patternCount("BBBBB") > 0)
    return true;
  if (_whiteCaptures == 5 || patternCount("WWWWW") > 0)
    return true;
  if ((_black || _white) + 1 == uint512_t(1U) << (19 * 19))
    return true;
  return 0;
}

std::vector<std::array<int, 2> > PenteState::actions() const {
  std::vector<std::array<int, 2> > possible;

  if (_turn == 0)
    possible.push_back({ 9, 9 });
  if (_turn == 1)
    for (int r = 6; r < 13; r++)
      for (int c = 6; c < 13; c++)
        if (r < 7 || r > 11 || c < 7 || c > 11)
          possible.push_back({ r, c });
  if (_turn > 1)
    for (int r = 0; r < 19; r++)
      for (int c = 0; c < 19; c++)
        if (getState({ r, c }) == 0)
          possible.push_back({ r, c });

  // Shuffle the options
  for (int i = 0; i < possible.size(); i++) {
    int j = rand() % possible.size();
    auto t = possible[i];
    possible[i] = possible[j];
    possible[j] = t;
  }

  std::vector<std::array<int, 2> > actions;
  for (auto p : possible)
    actions.push_back(p);

  return actions;
}

std::vector<std::array<int, 2> > PenteState::winningMoves() const {
  std::vector<std::array<int, 2> > options;
  if (_turn % 2 == 0) {
    for (auto p : patternLocation("BBBB*"))
      options.push_back(p);
    for (auto p : patternLocation("BBB*B"))
      options.push_back(p);
    for (auto p : patternLocation("BB*BB"))
      options.push_back(p);

    for (auto p : patternLocation("BWW*"))
      if (_blackCaptures + captureCount(p) >= 5)
        options.push_back(p);
  } else {
    for (auto p : patternLocation("WWWW*"))
      options.push_back(p);
    for (auto p : patternLocation("WWW*W"))
      options.push_back(p);
    for (auto p : patternLocation("WW*WW"))
      options.push_back(p);

    for (auto p : patternLocation("WBB*"))
      if (_whiteCaptures + captureCount(p) >= 5)
        options.push_back(p);
  }

  return options;
}

std::vector<std::array<int, 2> > PenteState::blockingMoves() const {
  PenteState nullState{ *this };
  nullState._turn++;

  if (nullState.winningMoves().empty())
    return {};

  std::vector<std::array<int, 2> > possibilities, blockingMoves;
  if (_turn % 2 == 0) {
    for (auto p : patternLocation("WWWW*"))
      possibilities.push_back(p);
    for (auto p : patternLocation("WWW*W"))
      possibilities.push_back(p);
    for (auto p : patternLocation("WW*WW"))
      possibilities.push_back(p);
  } else {
    for (auto p : patternLocation("BBBB*"))
      possibilities.push_back(p);
    for (auto p : patternLocation("BBB*B"))
      possibilities.push_back(p);
    for (auto p : patternLocation("BB*BB"))
      possibilities.push_back(p);
  }
  for (auto p : patternLocation("BWW*"))
    possibilities.push_back(p);
  for (auto p : patternLocation("WBB*"))
    possibilities.push_back(p);

  for (auto p : possibilities) {
    PenteState newState = result(p);
    if (newState.winningMoves().empty()) {
      blockingMoves.push_back(p);
    }
  }

  return blockingMoves;
}

std::vector<std::array<int, 2> >
PenteState::pieceNeighborhood(int radius) const {
  uint512_t base = _black | _white;
  uint512_t current = base;

  for (int i = 0; i < radius; i++) {
    uint512_t ngh{ current };

    ngh |= ((current << 1) &
            uint512_t("89589789687112168422297691222737771124865819889385981395"
                      "99956403855167484720643781523509973086428463103"));
    ngh |= ((current >> 1) &
            uint512_t("23485381032758049078410569481377458390818141606352005518"
                      "61180525743983239983515903293060657745007685175869439"));

    uint512_t ngh2{ ngh };
    ngh2 |= ((ngh << 19) & ((uint512_t(1) << 361) - 1));
    ngh2 |= (ngh >> 19) & ((uint512_t(1) << 361) - 1);

    current |= ngh2;
  }

  current = current & ((uint512_t(1) << 361) - 1 - base);

  std::vector<std::array<int, 2> > neighborhood;

  if (_turn == 0)
    neighborhood.push_back({ 9, 9 });
  if (_turn == 1)
    for (int r = 6; r < 13; r++)
      for (int c = 6; c < 13; c++)
        if (r < 7 || r > 11 || c < 7 || c > 11)
          neighborhood.push_back({ r, c });
  if (_turn > 1)
    for (int r = 0; r < 19; r++)
      for (int c = 0; c < 19; c++)
        if ((current & (uint512_t(1) << (19 * r + c))) != 0)
          neighborhood.push_back({ r, c });

  // Shuffle the options
  for (int i = 0; i < neighborhood.size(); i++) {
    int j = rand() % neighborhood.size();
    auto t = neighborhood[i];
    neighborhood[i] = neighborhood[j];
    neighborhood[j] = t;
  }

  return neighborhood;
}

PenteState PenteState::result(std::array<int, 2> position) const {
  PenteState newState{ *this };
  if (_turn % 2 == 0) {
    newState._setState(position, 1);
    newState._blackCaptures += captureCount(position);
  } else {
    newState._setState(position, -1);
    newState._whiteCaptures += captureCount(position);
  }
  newState._turn++;

  for (auto direction : std::vector<std::array<int, 2> >{ { 1, 0 },
                                                          { -1, 0 },
                                                          { 0, 1 },
                                                          { 0, -1 },
                                                          { 1, 1 },
                                                          { 1, -1 },
                                                          { -1, 1 },
                                                          { -1, -1 } }) {

    if (position[0] + 3 * direction[0] >= 0 &&
        position[0] + 3 * direction[0] < 19 &&
        position[1] + 3 * direction[1] >= 0 && position[1] + 3 * direction[1]) {

      bool capture = true;
      if (_turn % 2 == 0) {
        if (getState({ position[0] + 3 * direction[0],
                       position[1] + 3 * direction[1] }) != 1)
          capture = false;
        else if (getState({ position[0] + 2 * direction[0],
                            position[1] + 2 * direction[1] }) != -1)
          capture = false;
        else if (getState({ position[0] + direction[0],
                            position[1] + direction[1] }) != -1)
          capture = false;
      } else {
        if (getState({ position[0] + 3 * direction[0],
                       position[1] + 3 * direction[1] }) != -1)
          capture = false;
        else if (getState({ position[0] + 2 * direction[0],
                            position[1] + 2 * direction[1] }) != 1)
          capture = false;
        else if (getState({ position[0] + direction[0],
                            position[1] + direction[1] }) != 1)
          capture = false;
      }

      if (capture) {
        newState._setState(
            { position[0] + direction[0], position[1] + direction[1] }, 0);
        newState._setState(
            { position[0] + 2 * direction[0], position[1] + 2 * direction[1] },
            0);
      }
    }
  }
  return newState;
}

int PenteState::patternCount(std::string pattern) const {
  if (pattern.size() == 0)
    return 0;

  int count = 0;

  std::set<std::string> patterns;
  patterns.insert(pattern);
  std::reverse(pattern.begin(), pattern.end());
  patterns.insert(pattern);

  for (auto pattern : patterns) {
    for (auto direction : std::vector<std::array<int, 2> >{
           { 1, 0 }, { 0, 1 }, { 1, 1 }, { 1, -1 }
         }) {
      uint512_t current;
      if (pattern[0] == 'W')
        current = _white;
      else if (pattern[0] == 'B')
        current = _black;
      else if (pattern[0] == 'b')
        current = (uint512_t(1) << 361) - 1 - _black;
      else if (pattern[0] == 'w')
        current = (uint512_t(1) << 361) - 1 - _white;
      else
        current = (uint512_t(1) << 361) - 1 - (_white | _black);

      int shiftAmount = 19 * direction[0] + direction[1];
      for (int i = 1; i < pattern.size(); i++) {
        current <<= shiftAmount;

        if (direction[0] > 0) {
          current &= (uint512_t(1) << 361) - 1;
        }
        if (direction[1] > 0) {
          current &=
              uint512_t("4697076206551609815682113896275491678163628321270401"
                        "103722361051"
                        "487966479967031806586121315490015370351738878");
        } else if (direction[1] < 0) {
          current &=
              uint512_t("2348538103275804907841056948137745839081814160635200"
                        "551861180525"
                        "743983239983515903293060657745007685175869439");
        }

        if (pattern[i] == 'B')
          current &= _black;
        else if (pattern[i] == 'W')
          current &= _white;
        else if (pattern[0] == 'b')
          current &= (uint512_t(1) << 361) - 1 - _black;
        else if (pattern[0] == 'w')
          current &= (uint512_t(1) << 361) - 1 - _white;
        else
          current &= (uint512_t(1) << 361) - 1 - (_white | _black);
      }

      count += __builtin_popcountll((uint64_t)current);
      count += __builtin_popcountll((uint64_t)(current >> 64ULL));
      count += __builtin_popcountll((uint64_t)(current >> 128ULL));
      count += __builtin_popcountll((uint64_t)(current >> 192ULL));
      count += __builtin_popcountll((uint64_t)(current >> 256ULL));
      count += __builtin_popcountll((uint64_t)(current >> 320ULL));
    }
  }

  return count;
}

std::vector<std::array<int, 2> >
PenteState::patternLocation(std::string pattern) const {
  if (pattern.size() == 0)
    return {};

  std::vector<std::array<int, 2> > locations;

  std::set<std::string> patterns;
  patterns.insert(pattern);
  std::reverse(pattern.begin(), pattern.end());
  patterns.insert(pattern);

  for (auto pattern : patterns) {
    for (auto direction : std::vector<std::array<int, 2> >{
           { 1, 0 }, { 0, 1 }, { 1, 1 }, { 1, -1 }
         }) {
      uint512_t current;
      if (pattern[0] == 'W')
        current = _white;
      else if (pattern[0] == 'B')
        current = _black;
      else if (pattern[0] == 'b')
        current = (uint512_t(1) << 361) - 1 - _black;
      else if (pattern[0] == 'w')
        current = (uint512_t(1) << 361) - 1 - _white;
      else
        current = (uint512_t(1) << 361) - 1 - (_white | _black);

      int shiftAmount = 19 * direction[0] + direction[1];
      for (int i = 1; i < pattern.size(); i++) {
        current <<= shiftAmount;

        if (direction[0] > 0) {
          current &= (uint512_t(1) << 361) - 1;
        }
        if (direction[1] > 0) {
          current &=
              uint512_t("4697076206551609815682113896275491678163628321270401"
                        "103722361051"
                        "487966479967031806586121315490015370351738878");
        } else if (direction[1] < 0) {
          current &=
              uint512_t("2348538103275804907841056948137745839081814160635200"
                        "551861180525"
                        "743983239983515903293060657745007685175869439");
        }

        if (pattern[i] == 'B')
          current &= _black;
        else if (pattern[i] == 'W')
          current &= _white;
        else if (pattern[0] == 'b')
          current &= (uint512_t(1) << 361) - 1 - _black;
        else if (pattern[0] == 'w')
          current &= (uint512_t(1) << 361) - 1 - _white;
        else
          current &= (uint512_t(1) << 361) - 1 - (_white | _black);
      }

      int count = 0;
      count += __builtin_popcountll((uint64_t)current);
      count += __builtin_popcountll((uint64_t)(current >> 64ULL));
      count += __builtin_popcountll((uint64_t)(current >> 128ULL));
      count += __builtin_popcountll((uint64_t)(current >> 192ULL));
      count += __builtin_popcountll((uint64_t)(current >> 256ULL));
      count += __builtin_popcountll((uint64_t)(current >> 320ULL));

      if (count > 0) {
        int offset = pattern.size() - 1 - pattern.find("*");
        for (int i = 0; i < 361; i++)
          if ((current & (uint512_t(1U) << i)) != 0) {
            int r = i / 19 - direction[0] * offset;
            int c = i % 19 - direction[1] * offset;
            locations.push_back({ r, c });
          }
      }
    }
  }

  return locations;
}

int PenteState::captureCount(std::array<int, 2> position) const {
  int count = 0;

  for (auto direction : std::vector<std::array<int, 2> >{ { 1, 0 },
                                                          { -1, 0 },
                                                          { 0, 1 },
                                                          { 0, -1 },
                                                          { 1, 1 },
                                                          { 1, -1 },
                                                          { -1, 1 },
                                                          { -1, -1 } }) {

    if (position[0] + 3 * direction[0] >= 0 &&
        position[0] + 3 * direction[0] < 19 &&
        position[1] + 3 * direction[1] >= 0 && position[1] + 3 * direction[1]) {

      bool capture = true;
      if (_turn % 2 == 0) {
        if (getState({ position[0] + 3 * direction[0],
                       position[1] + 3 * direction[1] }) != 1)
          capture = false;
        else if (getState({ position[0] + 2 * direction[0],
                            position[1] + 2 * direction[1] }) != -1)
          capture = false;
        else if (getState({ position[0] + direction[0],
                            position[1] + direction[1] }) != -1)
          capture = false;
      } else {
        if (getState({ position[0] + 3 * direction[0],
                       position[1] + 3 * direction[1] }) != -1)
          capture = false;
        else if (getState({ position[0] + 2 * direction[0],
                            position[1] + 2 * direction[1] }) != 1)
          capture = false;
        else if (getState({ position[0] + direction[0],
                            position[1] + direction[1] }) != 1)
          capture = false;
      }

      if (capture)
        count++;
    }
  }
  return count;
}

void PenteState::display() const {
  std::cout << "Turn " << getTurn() << ", captures " << numCaptures()[0] << "-"
            << numCaptures()[1] << std::endl;
  std::cout << std::endl << "   ABCDEFGHIJKLMNOPQRS" << std::endl;
  for (int r = 0; r < 19; r++) {
    std::cout << std::setw(2) << (r + 1) << " ";
    for (int c = 0; c < 19; c++) {
      switch (getState({ r, c })) {
      case 1:
        std::cout << 'B';
        break;
      case -1:
        std::cout << 'W';
        break;
      default:
        std::cout << ' ';
        break;
      }
    }
    std::cout << std::endl;
  }
}

void PenteState::_setState(std::array<int, 2> position, int state) {
  if (state == 1)
    _black |= uint512_t(1U) << (19 * position[0] + position[1]);
  else if (state == -1)
    _white |= uint512_t(1U) << (19 * position[0] + position[1]);
  else {
    _black &= (uint512_t(1U) << 361) - 1 -
              (uint512_t(1U) << (19 * position[0] + position[1]));
    _white &= (uint512_t(1U) << 361) - 1 -
              (uint512_t(1U) << (19 * position[0] + position[1]));
  }
}

std::tuple<int, int, int, uint512_t, uint512_t> PenteState::fullState() const {
  return std::make_tuple(_turn, _blackCaptures, _whiteCaptures, _black, _white);
}

double PenteState::evaluate(int passes) const {
  double score = 0;
  for (int i = 0; i < passes; i++) {
    PenteState current(*this);
    while (!current.gameOver()) {
      auto winning = current.winningMoves();
      if (!winning.empty()) {
        current = current.result(winning[rand() % winning.size()]);
      } else {
        auto blocking = current.blockingMoves();
        if (!blocking.empty()) {
          current = current.result(blocking[rand() % blocking.size()]);
        } else {
          auto actions = current.pieceNeighborhood(2);
          current = current.result(actions[rand() % actions.size()]);
        }
      }
    }
    score += .5 + .5 * current.winner();
  }
  return 100. * score / passes;
}

bool PenteState::operator<(const PenteState &other) const {
  return std::make_tuple(_black, _white, _turn, _blackCaptures,
                         _whiteCaptures) <
         std::make_tuple(other._black, other._white, other._turn,
                         other._blackCaptures, other._whiteCaptures);
}
